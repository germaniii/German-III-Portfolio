;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   Thu Nov 5 2020
; Processor: 8086
; Compiler:  MASM32
;
; Before starting simulation set Internal Memory Size 
; in the 8086 model properties to 0x10000
;
;	GERMAN E FELISARTA III 16101002	CpE3104 Grp 1
;
;====================================================================

PROCED1 SEGMENT
ISR1 PROC FAR
ASSUME CS:PROCED1, DS:DATA
ORG 08000H              	; write code within below starting at address 08000H

        PUSHF               ; push 16-bit operands
        PUSH AX             ; save program context
        PUSH DX
            
        MOV DX, PORTA	   ; display '9' on the 7-segment in PORTA
        MOV AL, 09H   
        OUT DX, AL          
            
        POP DX              ; retrieve program context
        POP AX
        POPF                ; pop 16-bit operands
        IRET    	    ; return from interrupt
	
	
ISR1 ENDP                   ; end of procedure
PROCED1 ENDS
    
PROCED2 SEGMENT
ISR2 PROC FAR   
ASSUME CS:PROCED2, DS:DATA
ORG 09000H              	; write code within below starting at address 09000H

        PUSHF               ; push 16-bit operands
        PUSH AX             ; save program context
        PUSH DX
            
        MOV DX, PORTA	    ; display '0' on the 7-segment in PORTA
        MOV AL, 00H
        OUT DX, AL          
            
        POP DX              ; retrieve program context
        POP AX
        POPF                ; pop 16-bit operands
        IRET                ; return from interrupt
	
ISR2 ENDP                   ; end of procedure
PROCED2 ENDS

DATA SEGMENT
ORG 0F000H

    PORTA   EQU 0F0H    ; PORTA address
    PORTB   EQU 0F2H    ; PORTB address
    PORTC   EQU 0F4H    ; PORTC address
    COM_REG EQU 0F6H    ; Command Register Address 
    PIC1    EQU 0F8H    ; A1 = 0
    PIC2    EQU 0FAH    ; A1 = 1
    ICW1    EQU 013H    ; 8259 command word ICW1
    ICW2    EQU 080H    ; 8259 command word ICW2
    ICW4    EQU 03H     ; 8259 command word ICW4
    OCW1    EQU 0FCH    ; 8259 command word OCW1   
    
DATA ENDS

STK SEGMENT STACK
    BOS DW 64D DUP(?)   ; stack depth (bottom of stack)
    TOS LABEL WORD      ; top of stack
STK ENDS

CODE SEGMENT PUBLIC 'CODE'
ASSUME CS:CODE, DS:DATA, SS:STK

    ORG 0E000H          ; write code within below starting at address 0E000H
    
    START:
        MOV AX, DATA   
        MOV DS, AX      ; set the data segment address
        MOV AX, STK
        MOV SS, AX      ; set the stack segment address
        LEA SP, TOS     ; set the address of SP as top of stack
        
        CLI             ; clears IF flag
        
        ; program the 8255
        MOV DX, COM_REG
        MOV AL, 10001001B
        OUT DX, AL
        MOV DX, PORTA
        MOV AL, 00H
        OUT DX, AL
        
        ; program the 8259
        MOV DX, PIC1    ; set the I/O address to access ICW1
        MOV AL, ICW1
        OUT DX, AL      ; send command word
        MOV DX, PIC2    ; set the I/O address to access ICW2, ICW4 and OCW1
        MOV AL, ICW2
        OUT DX, AL      ; send command word
        MOV AL, ICW4    
        OUT DX, AL      ; send command word
        MOV AL, OCW1
        OUT DX, AL      ; send command word
        STI             ; enable INTR pin of 8086
        
        ; storing interrupt vector to interrup vector table in memory
        MOV AX, OFFSET ISR1 ; get offset address of ISR1(IP)
        MOV [ES:200H], AX   ; store offset address  to memory
        MOV AX, SEG ISR1    ; get segment address of ISR1 (CS)
        MOV [ES:202H], AX   ; store segment address to memory 

        
        MOV AX, OFFSET ISR2 ; get offset address of ISR2 (IP)
        MOV [ES:204H], AX   ; store offset address to memory
        MOV AX, SEG ISR2    ; get segment address of ISR2 (CS)
        MOV [ES:206H], AX   ; store segment address to memory 

        
    ; foreground routine  
    HERE: 
	 MOV DX, PORTC		; select portc
	 IN AL, DX		; import input
	 AND AL, 0FH		; convert the high upper nibble into low so that it can be properly compared
	 
	 CMP AL, 09H		;checks if input is less than or equal to 9
	 JLE DISPLAY
	 MOV AL, 00H		; if greater than then display 0
	 
	 DISPLAY:
	    MOV DX, PORTB	; select portb
	    OUT DX, AL		; output the input or 0
	    
	 JMP HERE
        
CODE ENDS  
END START  